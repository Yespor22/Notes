## Reflection
反射机制使得程序能够在运行时反观和修改内部结构，反射允许程序在运行时动态地操作类和对象。
包括创建对象、访问字段和调用方法等等，但对于构建灵活的运用和复杂的框架非常重要

### 为什么要引入反射
需要在运行时动态的操作成员，例如根据数据库中提供的类名或方法名或者基于字符串变量来动态实例化对象或调用方法时。 
关键在于一个特殊的对象类对象

### 操作对象
通过类的构造器来创建实例，简单来说先从目标类的Class对象中选择一个合适的构造器，然后通过调用他的newInstance方法来创建对象

newIstance创建的对象是在运行时动态生成的，无法在编译阶段确切知道创建对象的类型，使用Object类型来接收

反射直接调用和操作对象的方法和字段
原因：在编写阶段明确转换类型，直接显示地调用更合适，而不必依赖于反射
反射真正的价值在于**处理编译时未知的类型，从而编写更具有通用性的代码**

### 反射的最佳实践（模拟框架）
创建Order实例并自动将Custormer和Address服务注入到Order实力当中

动态场景时存在限制，一旦代码完成，无法动态创建对象或调用方法

反射实现动态:"效仿常用框架的处理方式"



### 例子

Mybatis非常智能，配置映射关系，查询结果转换为实体类，属性会自动按照字段名称一一对应，免去了JDBC的繁琐操作。

- 底层通过反射赋值


mapUnderscoreToCameCase A_COLUMN -> aColumn

实际上Mybatis一开始会通过我们实体类默认的无参构造得到一个最初的对象，然后通过反射进行赋值，

Mybatis调用无参构造对象，属性则是通过反射进行赋值

但是注意，Mybatis仅仅是使用这种方式进行对象的构建，而字段的赋值无论是什么构造方法，都会使用反射进行一次赋值：

**接口注解**